import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";
import JSZip from "jszip";
import { TaxResult, RawPayrollRecord } from "@/lib/ephemeral-engine/types";
import { generateZimraXml } from "@/lib/xml-generator";
import { generateGLCSV } from "@/lib/ephemeral-engine/gl-exporter";

// Combine raw record and calculation result
type FullRecord = RawPayrollRecord & { taxResult: TaxResult };

export async function generatePayslipPDF(record: FullRecord, orgName: string, logoUrl?: string | null): Promise<ArrayBuffer> {
  const doc = new jsPDF();
  
  let yOffset = 20;

  // Add Logo if available
  if (logoUrl) {
    try {
        // Create an image element to load the logo
        // Note: In a browser environment, we might need to fetch the image data first
        // or use an existing Image object. For now, we'll try to add it directly if it's a base64 string
        // or a URL that jsPDF can handle (CORS might be an issue with external URLs).
        // Assuming Data URI or simple URL for now.
        
        // For simple URL implementation in client-side jsPDF:
        const img = new Image();
        img.src = logoUrl;
        await new Promise((resolve, reject) => {
             img.onload = resolve;
             img.onerror = reject;
        });
        
        // Calculate aspect ratio to fit in a box of 40x20
        const maxWidth = 40;
        const maxHeight = 20;
        const ratio = Math.min(maxWidth / img.width, maxHeight / img.height);
        const width = img.width * ratio;
        const height = img.height * ratio;

        doc.addImage(img, "PNG", 14, 10, width, height);
        
        // If logo is present, we might want to center the text relative to the page 
        // but keep the Y position similar or slightly adjusted.
    } catch (e) {
        console.warn("Failed to load logo", e);
    }
  }

  // Header
  doc.setFontSize(18);
  doc.text(orgName, 105, yOffset, { align: "center" });
  doc.setFontSize(14);
  doc.text("Payslip", 105, yOffset + 10, { align: "center" });
  
  doc.setFontSize(10);
  doc.text(`Employee: ${record.name} (${record.employeeId})`, 14, 45);
  doc.text(`TIN: ${record.tin || "N/A"}`, 14, 50);
  doc.text(`Date: ${new Date().toLocaleDateString()}`, 150, 45);
  doc.text(`Currency: ${record.currency}`, 150, 50);
  doc.text(`Tax Method: ${record.taxResult.method || "PAYE"}`, 150, 55);

  // Table Data
  const { taxResult } = record;
  const currency = record.currency;
  
  const bodyData = [
    ["Basic Salary", `${currency} ${record.basicSalary.toFixed(2)}`],
    ["Allowances", `${currency} ${(record.allowances || 0).toFixed(2)}`],
    ...(record.exemptAllowances ? [["Exempt Allowances", `${currency} ${record.exemptAllowances.toFixed(2)}`]] : []),
    [{ content: "Gross Income", styles: { fontStyle: "bold" } }, { content: `${currency} ${taxResult.grossIncome.toFixed(2)}`, styles: { fontStyle: "bold" } }],
    ["", ""], // Spacer
    ["Deductions", ""],
    ["NSSA (Pension)", `-${currency} ${taxResult.nssa.toFixed(2)}`],
    ["NEC", `-${currency} ${(taxResult.nec || 0).toFixed(2)}`], // Handle undefined safely
    ["PAYE (Tax)", `-${currency} ${taxResult.paye.toFixed(2)}`],
    ["AIDS Levy", `-${currency} ${taxResult.aidsLevy.toFixed(2)}`],
    [{ content: "Total Deductions", styles: { fontStyle: "bold" } }, { content: `-${currency} ${taxResult.totalDeductions.toFixed(2)}`, styles: { fontStyle: "bold" } }],
    ["", ""], // Spacer
    [{ content: "NET PAY", styles: { fillColor: [220, 255, 220], fontStyle: "bold", fontSize: 12 } }, { content: `${currency} ${taxResult.netPay.toFixed(2)}`, styles: { fillColor: [220, 255, 220], fontStyle: "bold", fontSize: 12 } }]
  ];

  autoTable(doc, {
    startY: 65,
    head: [["Description", "Amount"]],
    body: bodyData as any,
    theme: "grid",
    headStyles: { fillColor: [40, 40, 40] },
    columnStyles: {
      0: { cellWidth: 120 },
      1: { cellWidth: 60, halign: "right" }
    }
  });

  // Footer
  const finalY = (doc as any).lastAutoTable.finalY + 20;
  doc.setFontSize(8);
  doc.text("Generated by Zim-PayConnect", 14, finalY);
  
  return doc.output("arraybuffer");
}

export async function generateBatchZip(records: FullRecord[], orgName: string, logoUrl?: string | null, tin?: string): Promise<Blob> {
  const zip = new JSZip();
  const rootFolder = zip.folder(`Payslips-${new Date().toISOString().split('T')[0]}`);

  // Split records
  const fdsRecords = records.filter(r => r.isPermanent !== false); // Default to true
  const nonFdsRecords = records.filter(r => r.isPermanent === false);

  const fdsFolder = fdsRecords.length > 0 ? rootFolder?.folder("FDS_Permanent") : null;
  const nonFdsFolder = nonFdsRecords.length > 0 ? rootFolder?.folder("Non_FDS_Casual") : null;

  // Helper to generate files for a batch
  const processBatch = async (batch: FullRecord[], folder: JSZip | null | undefined, summaryName: string) => {
    if (!batch.length || !folder) return;

    // PDFs
    for (const record of batch) {
      const pdfBuffer = await generatePayslipPDF(record, orgName, logoUrl);
      const fileName = `${record.name.replace(/[^a-z0-9]/gi, '_')}_${record.employeeId}.pdf`;
      folder.file(fileName, pdfBuffer);
    }

    // CSV Summary
    let csvContent = `EmployeeID,Name,Gross,NSSA,NEC,Taxable,PAYE,AIDS_Levy,NetPay,SDF_Employer,Method,YTD_Gross,YTD_Tax_Paid
`;
    batch.forEach(r => {
      const t = r.taxResult;
      csvContent += `${r.employeeId},${r.name},${t.grossIncome.toFixed(2)},${t.nssa.toFixed(2)},${(t.nec || 0).toFixed(2)},${t.taxableIncome.toFixed(2)},${t.paye.toFixed(2)},${t.aidsLevy.toFixed(2)},${t.netPay.toFixed(2)},${(t.sdf || 0).toFixed(2)},${t.method || "PAYE"},${r.ytdGross || 0},${r.ytdTaxPaid || 0}
`;
    });
    folder.file(summaryName, csvContent);
  };

  // Process both batches
  await processBatch(fdsRecords, fdsFolder, "FDS_Summary.csv");
  await processBatch(nonFdsRecords, nonFdsFolder, "Non_FDS_Summary.csv");

  // Generate ZIMRA XML Return (Combined)
  if (tin) {
      try {
          const xmlContent = generateZimraXml(records, orgName, tin);
          rootFolder?.file("Zimra_Return_XML.xml", xmlContent);
      } catch (e) {
          console.warn("Failed to generate ZIMRA XML", e);
      }
  }

  // Generate GL Export (Combined)
  try {
      const glCsv = generateGLCSV(records, orgName);
      rootFolder?.file("General_Ledger.csv", glCsv);
  } catch (e) {
      console.warn("Failed to generate GL CSV", e);
  }

  return await zip.generateAsync({ type: "blob" });
}
